Язык в курсе - LISP
`L1 введение, структура курса`
Базовая информация

`L2 (Listp, SCIM)` ================================================================================
На сайте нет информации чем пользоваться, как запускать (Диалект Racket)

Язык который взялся за решение проблем описания процессов и комплексных систем должен иметь как миминмум 3 вещи:
1) Иметь возможность создавать примитивные выражения (сложение\определение чисел)
2) Должны быть методы комбинирования этих простых выражений чтобы получить выражения более сложные
3) Должны быть способы создания абстракций (черных ящиков)

`Базовые операторы лиспа`
Lisp использует префиксную нотацию - в начале оператор, затем операнды
Скобки означают что это выражение

(+ 1 2) - выполнить сложение 1 и 2. (количество операндов любое в разумных пределах)
(- 2 3) - вычитание
(* 2 3) - умножение
(/ 2 4) - деление

выражения можно встраивать в другие выражения

(+ (* 10 2) (* 2 4)) тоже самое что ((10*2)+(2*4))
================================================================================
присвоить значение некоторой переменной\постоянной pi2
(define pi2 1.14159)
Переорпделить значение - просто повторить команды

`определение функций`
(define curcumferense (* 2 pi raidus))

`compaund procedures` (составные процедуры) - процедура это процесс, поэтому нжуно вызывать через скобки
(define (square x) (* x x))
если обращаться без скобок - получим описание .

`Пример условия (cond) `
(define (abs x)
    (cond ((> x 0) x)
            ((= x 0) 0)
            (< x 0) (- x))))
Синтаксический сахар - если у условия только 2 варианта можно использовать  (if (УСЛОВИЕ) (TRUE) (FALSE))
 (define (abs x))
    (if (< x 0) (- x) x)

`Логические операции`
(define (>= x y)
    (not (< x y)))

`Рекурcия`

(define (sqrt-iter guess x)
    (if (good-enough? guess x) guess 
        (sqrt-iter (improve guess x) x)))

(define (improve quess x)
    (average guess (/ x guess)))

(define (average a b)
    (/(+ a b) 2))

(define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.01))

(define (sqrt x)
    (sqrt-iter 1.0 x))
================================================================================
`L3 Процедуры как асбстракции` ================================================================================
================================================================================
Инкапсуляция?

(define (sqrt x)
    (define (good-enough? guess x)
        (< (abs (- (square guess) x)) 0.01))
    (define (improve guess x)
        (average guess (/ x guess)))
    (define (average a b)
        (/ (+ a b) 2))
    (define (sqrt-iter guess x)
        (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x)))
    (sqrt-iter 1.0 x)
    )

Упрощение (Исключаем лишнее объявление x т.к. он передается первым параметром):

(define (sqrt x)
    (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.01))
    (define (improve guess)
        (average guess (/ x guess)))
    (define (average a b)
        (/ (+ a b) 2))
    (define (sqrt-iter guess)
        (if (good-enough? guess) guess (sqrt-iter (improve guess))))
    (sqrt-iter 1.0)
    )

Дз - написать программу которая принимает три числа и возвращает сумму квадратов двух наибольших чисел

(define (sum-of-squares-of-top-two a b c)
  (cond ((and (< a b) (< a c)) (+ (* b b) (* c c)))
        ((and (< b a) (< b c)) (+ (* a a) (* c c)))
        (else (+ (* a a) (* b b)))
  )
)

================================================================================
`L4 Процедуры и порождаемые ими процессы 1` ================================================================================
================================================================================
важно как компьютер использует процедуры. 

Определение факториала мой вариант
(define (fact x)
    (if (> x 0) (* x (fact (- x 1))) (+ x 1)))

вариант преподавателя 
Линейный рекурсивный процесс 
(define (fact n)
    (if (= n 1) 1)
        (* n (fact (- n 1)))
    )

Есть вариант рассмотреть факториал с другой стороны:
 n!= 1*2*3*...*n

 x=x*counter
 counter=conunter+1

 (fact 6)
 (fact-iter 1 1 6)
 1 2 6 
 2 3 6 
 6 4 6
 24 5 6
 120 6 6
 720 7 6 - рнешение

 второй вариант линейный итеративный процесс  (свой)
 (define (fact-iter x count target)
  (cond ((= target 1) 1)
        ((< count target) (fact-iter(* x count) (+ count 1) target))
        (else (* x count))
  )
  )

(define (fact2 x)
  (fact-iter 1 1 x)
  )

================================================================================
`L5 Процедуры и порождаемые ими процессы 2` ================================================================================
================================================================================
Рекурсивный процесс и рекурсивная процедура - разные вещи! 


`HOMEWORK CODE` 
Реализуйте функцию Аккермана A. Она принимает два параметра, x и y, и вычисляется следующим образом:

если y = 0, тогда она возвращает 0;
если x = 0, тогда она возвращает 2*y;
если y = 1, тогда она возвращает 2;
иначе, она вызывает саму себя (фукнцию A) с параметрами x = x-1 и y = A ( x, (y - 1) ).

#lang racket/base

(require rackunit)

;; BEGIN (write your solution here)
(define (A x y)
  (cond ((= y 0) 0)
    ((= x 0) (* y 2))
    ((= y 1) 2)
    (else (A (- x 1) (A x (- y 1))))
  )
)
;; END

(check-equal? (A 1 10) 1024)
(check-equal? (A 2 4) 65536)
(check-equal? (A 3 3) 65536)

   
================================================================================
`L6 Древовидная рекрсия` ================================================================================
================================================================================

Последовательность фибоначи - кажое последующее число состоит из суммы двух предыдущих, фиб 0 =0 фиб 1 =1.

 (define (fibl n)
        (cond ((= n 0) 0)
            ((= n 1) 1)
            (else (+ (fibl (- n 1))
                    (fibl (- n 2))
                    )))
        )



Линейно итеративный вариант:
(define (fib n) (fib-iter 1 0 n))
(define (fib-iter a b count)
    (if (= count 0) b
        (fib-iter (+ a b) a (- count 1)))
)

`HOMEWORK CODE` 
Функция f задана таким образом:
f(n) = n if n < 3, and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n >= 3.
В файле function_f.rkt создайте процедуру f, которая вычисляет f с помощью рекурсивного процесса или итеративного процесса.

(define (f n)
  (cond ((< n 3) n)
        (else (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))) )) 
          )
  )


Числа на краю – всегда единицы. Каждое число внутри треугольника это сумма двух чисел сверху.

В файле pascal.rkt создайте процедуру, которая принимает координаты в виде пары чисел (строка и колонка) и вычисляет элементы Треугольника Паскаля с помощью рекурсивного процесса.

Например, число на третьей строке и второй колонке – 2, так что вызов (pascal-triangle 3 2) должен возвращать 2.
#lang racket/base

(require rackunit)

;; BEGIN (write your solution here)
(define (fact-iter x count target)
  (cond ((= target 1) 1)
        ((< count target) (fact-iter(* x count) (+ count 1) target))
        (else (* x count))
  )
  )
(define (fact x)
  (fact-iter 1 1 x)
  )

(define (pascal-triangle n x)
  (cond ((or (= x 1) (= x n)) 1)
        ((or (= x 2) (= x (- n 1))) (- n 1))
        ((= x 3) (/ (* (- n 1) (- (- n 1) 1)) 2))
        ((= x 4) (/ (* (- n 1) (+ (- n 1) 1) (+ (- n 1) 2)) 6))
        (else (/ (fact (- n 1)) (* (fact (x)) (fact (- (- n 1) x)) )))
        )
  )

  Решение учителя - 

  #lang racket/base

(require rackunit)

;; BEGIN
(define (pascal-triangle row col)
  (cond ((> col row) 0)
    ((< col 0) 0)
      ((= col 1) 1)
        ((+ (pascal-triangle (- row 1) (- col 1))
          (pascal-triangle (- row 1) col)))))
;; END

(check-equal? (pascal-triangle 1 1) 1)
(check-equal? (pascal-triangle 2 2) 1)
(check-equal? (pascal-triangle 3 2) 2)
(check-equal? (pascal-triangle 4 2) 3)
(check-equal? (pascal-triangle 5 2) 4)
(check-equal? (pascal-triangle 5 3) 6)


================================================================================
`L7 Порядки роста` =============================================================
================================================================================
Порядки роста - подводка к О. 
Вводная информация о количестве операций и их массивности при изменении входных данных

================================================================================
`L8 Возведение в степень` =============================================================
================================================================================

Пример
b^n
b^n=b*b^n-1, b^0=1

Линейно-рекурсивное решение (тета n шагов и тета n памяти)
(define (expt b n)
      ( if (= n 0) 1)
        (* b (expt b (- n 1)))
      )

Итеративно рекурсивный спосособ (тета n шагов НО константное количество памяти)
(define (expt b n)
      (exp-iter b n 1))
(define (expoter b counter prod)
        (if (= counter 0) prod
        (exp-ter b (-counter 1) (* product b))))

3ий вариант формульный - самый быстрый - меделнный рост количества шагов. (тета log2n)
b^8 = b*b*b*b*b*b*b*b*b
b^2= b*b
b^4= b^2*b^2
b^8= b^4*b^4
в общем виде
b^n=(b^b/2)^2 if n is even (четное)
b^2=(b*b^n-1) if n is not(even) (не четное)

(define (fast-exp b n)
  (cond ((= n 0)1)
  ((even? n)
    (square (fast-exp b (/ n 2))
    (else (* b (fast-exp b (- n 1)))))

================================================================================
`Лекция 3. L9 Наибольший общий делитель` =============================================================
================================================================================
поиск НОД
НОД двух чисел - такое число на которое деляться два числа без остатка


пример НОД(16,28) = 4
пример 16/28=4/7

Второй способ - алгорим Евклида
предположим r=остаток от деления a/b
то НОД (a,b)=НОД(b,r)

НОД(206, 40)=НОД (40,6) (при r240/40=6)
НОД (40,6)
НОД (6,4)
НОД (4,2)
(2,0) - 2 ответ.

(define (gcd a b)
        (if (=b 0)a
          (gcd b (remainder a b)
          )))

Число шагов растте пропорционально Log аргументов
(если алгоритму требуется k шагов, то меньший из членов пары больше или равно k-тому числу фибоначи)

пример - пусть n(меньший из а b)
n>= Fib(k)
~fi^k/sqrt(5)

================================================================================
`Лекция 3. L10 провека на простоту` =============================================================
================================================================================
Задача - дается число n необходимо проверить является ли это число простым или нет
Вариант в лоб: перебрать все числа до n и если ни один делитель не делит число без остатка, то n - простое число.
Порядок роста - тета корень(n)

(define (smallest-divisor n)
  (find-divisor n 2))
  
(define (find-divisor n test-divisor)
        (cond ((> (square test-devisor)n)n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1) ))))

(define (divides? a b)
        (= (remainder b a) 0))
    
(define (prime? n)
  (= n (smallest-divisor n)))

Вариант 2, основанный на малой теореме ферма. Алгоритм вероятностного метода.
Если n - простое, а a - произвольное целое число, такое что a<n, то
a^n эквивалентно a mod n

Если n - не является простым, то большинство не будет удовлетворять условию a<n
Алгоритм:
1) имея n, проверяем a<n
2) вычисляем остаток от деления a^n, n
3) Если остаток не равен a, то n - не простое
4) если остаток = a, то n простое. - возвращаемся к шагу n

================================================================================
`Лекция 3. L11 Процедуры в качестве аргументов` =============================================================
================================================================================


1) находит сумму всех чисел между a и b 
(define (sum-int a b)
    (if (> a b) 0
      (+ a (sum-int ( + a 1) b))))

2) находит сумму кубов между двумя числами
(defin (sum-cubes a b)
  (if (> a b) 0
    (+ (cube a) (sum-cubes ( + a 1 ) b))))

3) находит сумму ряда 1/(1*3) +1/(5*7) 1/(9*11).... = Pi/8
(define (pi-sum a b )
  (if (> a b) 0
   ( +  ( / 1.0 (* a (+ a 2)) (pi-sum (+ a 4) b)))))

   Скелет кода подходящий для всех трех процедур

(define (<имя> a b)
  (if (> a b)0
  (+ (<терм> a)
    ( <имя>(<след> a) b))))

=============== 1)
(define (sum term a next b)
  (if (> a b) 0
  (+ (term a)
      (sum term (next a) next b))))

(define (inc x) (+ 1 x))
(define (identity n) n)
(define (sum-int a b)
  (sum identity a inc b))

=============== 2)
(define (sum-cubes a b)
  (sum cube a inc b))

(define (inc x) (+ 1 x))
(define (identity n) n)
(define (sum-int a b)
  (sum identity a inc b))

=============== 3) Homework

(define (inc x) (+ 2 x))
(define (identity n) n)
(define (pi-sum a b)
  (if (> a b) 0
    (+ (/ 1.0 (* a (inc a) )) (pi-sum(inc (inc a))  b ))
   ))

================================================================================
`Лекция 3. L12 Построение процедур с помощью lambda` =============================================================
================================================================================

В лиспе и скиме есть понятие лямбда
(lambda (x) (+ x 4))

(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ a x))
       b))

Общий вид
((lambda (<параметр>) (<тело>))
  <параметр вызова>)

Под капотом создание простой функции выглядит так:
(define (plus4 a) (+ 4 a))  =eq= (define plus4 (lambda (x) (+ 4 x)))


================================================================================
`Лекция 3. L13 Построение процедур с помощью lambda` =============================================================
================================================================================
следвие существования лямбды - возможность создания переменных 

f(x,y)= x(1+xy)^2 + (y (1-y)) + (1+xy)(1-Y)
если a = (1+xy), b=(1-y)
то f(x,y)=xa^2+yb+ab

(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a)
      (* y b) (* a b)))
  f-helper (+ 1 (* x y)) (- 1 y) )))

Создание лоакльной преременной с помощью лямбды 
(define (f x y)
  ((lambda (a b)
    (+ (* x (square a)
     (* y b) (* a b)))
     (+ 1 (* x y) (- 1 y))
  )))

  let - инструмент для автосоздания переменных 
 (define (f x y)
  (let (( a (+1 (* x y))))
    (b (- 1 y)))
    (+ (* x (square a)) (* y  b) (* a b)
     ))

Синтаксис в общем случае:
Значение переменных существуют только внутри функции let
(let ((<пер1> <выражение1>)
      (<пер2> <выражение2>)
      ....
      <тело в котором эти переменные существуют>
))

При работе с let необходим помнить о нескольких вещах:
a) желетально использовать переменные скольугодно близко к месту где они будут использоваться.
x=5 
(+ (let (( x 3))
(+ x (* x 10))) x)  ==== 38

x=2
(let ((x 3) (y (+ x 2)) 
  (* x y)
  ))

================================================================================
`Лекция 4. L14 Метод половинного деления` =============================================================
================================================================================
Нахождение корней методом половинного деления

f(x)=0 - нужно найти корень , значем что f непрерывная функция

предположим f(a)< 0 < f(b), x=average(a,b)
проверяем f(x)>0 -> a, x
          f(x)<0 -> x, b

(define (serch f neg-p pos-p)
  (let (( mid-p average (neg-p pos-p)))
    (if (close-enough? neg-p pos-p)
      mid-p
      (let (( test-value (f mid-p)
        (cond ((positive tes-value)
          search f neg-p mid-p))
           ((negative? tes-value)
           (search f mid-p pos-p))
           ((else mid-p))))))
   )
)

(define (close-enough? x y)
  (< (abs (-x y)) 0.0001))

(define (half-interfal-method f a b )
  (let ((a-value ( f a ))
        (b-value ( f b)))
        (cond (( and (negative? (a-value)
          (positive? (b-value)
          (search f a b)
          ((and (negative? (b-value)
                (positive? (a-value)
                search f b a)
              (else (error "Errro!" a b )))
              ))
          ))))
        )
  )

================================================================================
`Лекция 4. L15 Нахождение неподвижных точек функций` =============================================================
================================================================================
неподвижная точка, это  такая точка f(x)=x
f(x), f(f(x)) ... и т.д.

(define tolerance 0.00001)

(define (fixed-point f first-quess)
        (define (close-enough? v1 v2)
          (< (abs (- v1 v2)) tolerance))
        
      (define (try guess) 
          (let((next (f guess)))
          (if (close-enough? guess next)
            next
            (try next))))
        
      (try first-quess))

Примеры вызовов:
(fixed-point cos 1.0)
===0.7390822985224024

вызов слямбдой y=siny+cosy

(fixed-point (lambda (y)(+ (sin y)(cos y)))1.0)
1.2587315962971173

y^2=x \\ y*y=x \\ y=x/y