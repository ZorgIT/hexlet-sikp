Язык в курсе - LISP
`L1 введение, структура курса`
Базовая информация

`L2 (Listp, SCIM)` ================================================================================
На сайте нет информации чем пользоваться, как запускать (Диалект Racket)

Язык который взялся за решение проблем описания процессов и комплексных систем должен иметь как миминмум 3 вещи:
1) Иметь возможность создавать примитивные выражения (сложение\определение чисел)
2) Должны быть методы комбинирования этих простых выражений чтобы получить выражения более сложные
3) Должны быть способы создания абстракций (черных ящиков)

`Базовые операторы лиспа`
Lisp использует префиксную нотацию - в начале оператор, затем операнды
Скобки означают что это выражение

(+ 1 2) - выполнить сложение 1 и 2. (количество операндов любое в разумных пределах)
(- 2 3) - вычитание
(* 2 3) - умножение
(/ 2 4) - деление

выражения можно встраивать в другие выражения

(+ (* 10 2) (* 2 4)) тоже самое что ((10*2)+(2*4))
================================================================================
присвоить значение некоторой переменной\постоянной pi2
(define pi2 1.14159)
Переорпделить значение - просто повторить команды

`определение функций`
(define curcumferense (* 2 pi raidus))

`compaund procedures` (составные процедуры) - процедура это процесс, поэтому нжуно вызывать через скобки
(define (square x) (* x x))
если обращаться без скобок - получим описание .

`Пример условия (cond) `
(define (abs x)
    (cond ((> x 0) x)
            ((= x 0) 0)
            (< x 0) (- x))))
Синтаксический сахар - если у условия только 2 варианта можно использовать  (if (УСЛОВИЕ) (TRUE) (FALSE))
 (define (abs x))
    (if (< x 0) (- x) x)

`Логические операции`
(define (>= x y)
    (not (< x y)))

`Рекурcия`

(define (sqrt-iter guess x)
    (if (good-enough? guess x) guess 
        (sqrt-iter (improve guess x) x)))

(define (improve quess x)
    (average guess (/ x guess)))

(define (average a b)
    (/(+ a b) 2))

(define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.01))

(define (sqrt x)
    (sqrt-iter 1.0 x))
================================================================================
`L3 Процедуры как асбстракции` ================================================================================
================================================================================
Инкапсуляция?

(define (sqrt x)
    (define (good-enough? guess x)
        (< (abs (- (square guess) x)) 0.01))
    (define (improve guess x)
        (average guess (/ x guess)))
    (define (average a b)
        (/ (+ a b) 2))
    (define (sqrt-iter guess x)
        (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x)))
    (sqrt-iter 1.0 x)
    )

Упрощение (Исключаем лишнее объявление x т.к. он передается первым параметром):

(define (sqrt x)
    (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.01))
    (define (improve guess)
        (average guess (/ x guess)))
    (define (average a b)
        (/ (+ a b) 2))
    (define (sqrt-iter guess)
        (if (good-enough? guess) guess (sqrt-iter (improve guess))))
    (sqrt-iter 1.0)
    )

Дз - написать программу которая принимает три числа и возвращает сумму квадратов двух наибольших чисел

(define (sum-of-squares-of-top-two a b c)
  (cond ((and (< a b) (< a c)) (+ (* b b) (* c c)))
        ((and (< b a) (< b c)) (+ (* a a) (* c c)))
        (else (+ (* a a) (* b b)))
  )
)

================================================================================
`L4 Процедуры и порождаемые ими процессы 1` ================================================================================
================================================================================
важно как компьютер использует процедуры. 

Определение факториала мой вариант
(define (fact x)
    (if (> x 0) (* x (fact (- x 1))) (+ x 1)))

вариант преподавателя 
Линейный рекурсивный процесс 
(define (fact n)
    (if (= n 1) 1)
        (* n (fact (- n 1)))
    )

Есть вариант рассмотреть факториал с другой стороны:
 n!= 1*2*3*...*n

 x=x*counter
 counter=conunter+1

 (fact 6)
 (fact-iter 1 1 6)
 1 2 6 
 2 3 6 
 6 4 6
 24 5 6
 120 6 6
 720 7 6 - рнешение

 второй вариант линейный итеративный процесс  (свой)
 (define (fact-iter x count target)
  (cond ((= target 1) 1)
        ((< count target) (fact-iter(* x count) (+ count 1) target))
        (else (* x count))
  )
  )

(define (fact2 x)
  (fact-iter 1 1 x)
  )

================================================================================
`L5 Процедуры и порождаемые ими процессы 2` ================================================================================
================================================================================
Рекурсивный процесс и рекурсивная процедура - разные вещи! 


`HOMEWORK CODE` 
Реализуйте функцию Аккермана A. Она принимает два параметра, x и y, и вычисляется следующим образом:

если y = 0, тогда она возвращает 0;
если x = 0, тогда она возвращает 2*y;
если y = 1, тогда она возвращает 2;
иначе, она вызывает саму себя (фукнцию A) с параметрами x = x-1 и y = A ( x, (y - 1) ).

#lang racket/base

(require rackunit)

;; BEGIN (write your solution here)
(define (A x y)
  (cond ((= y 0) 0)
    ((= x 0) (* y 2))
    ((= y 1) 2)
    (else (A (- x 1) (A x (- y 1))))
  )
)
;; END

(check-equal? (A 1 10) 1024)
(check-equal? (A 2 4) 65536)
(check-equal? (A 3 3) 65536)

   
================================================================================
`L6 Древовидная рекрсия` ================================================================================
================================================================================

Последовательность фибоначи - кажое последующее число состоит из суммы двух предыдущих, фиб 0 =0 фиб 1 =1.

 (define (fibl n)
        (cond ((= n 0) 0)
            ((= n 1) 1)
            (else (+ (fibl (- n 1))
                    (fibl (- n 2))
                    )))
        )



Линейно итеративный вариант:
(define (fib n) (fib-iter 1 0 n))
(define (fib-iter a b count)
    (if (= count 0) b
        (fib-iter (+ a b) a (- count 1)))
)

`HOMEWORK CODE` 
Функция f задана таким образом:
f(n) = n if n < 3, and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n >= 3.
В файле function_f.rkt создайте процедуру f, которая вычисляет f с помощью рекурсивного процесса или итеративного процесса.

(define (f n)
  (cond ((< n 3) n)
        (else (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))) )) 
          )
  )


Числа на краю – всегда единицы. Каждое число внутри треугольника это сумма двух чисел сверху.

В файле pascal.rkt создайте процедуру, которая принимает координаты в виде пары чисел (строка и колонка) и вычисляет элементы Треугольника Паскаля с помощью рекурсивного процесса.

Например, число на третьей строке и второй колонке – 2, так что вызов (pascal-triangle 3 2) должен возвращать 2.
#lang racket/base

(require rackunit)

;; BEGIN (write your solution here)
(define (fact-iter x count target)
  (cond ((= target 1) 1)
        ((< count target) (fact-iter(* x count) (+ count 1) target))
        (else (* x count))
  )
  )
(define (fact x)
  (fact-iter 1 1 x)
  )

(define (pascal-triangle n x)
  (cond ((or (= x 1) (= x n)) 1)
        ((or (= x 2) (= x (- n 1))) (- n 1))
        ((= x 3) (/ (* (- n 1) (- (- n 1) 1)) 2))
        ((= x 4) (/ (* (- n 1) (+ (- n 1) 1) (+ (- n 1) 2)) 6))
        (else (/ (fact (- n 1)) (* (fact (x)) (fact (- (- n 1) x)) )))
        )
  )

  Решение учителя - 

  #lang racket/base

(require rackunit)

;; BEGIN
(define (pascal-triangle row col)
  (cond ((> col row) 0)
    ((< col 0) 0)
      ((= col 1) 1)
        ((+ (pascal-triangle (- row 1) (- col 1))
          (pascal-triangle (- row 1) col)))))
;; END

(check-equal? (pascal-triangle 1 1) 1)
(check-equal? (pascal-triangle 2 2) 1)
(check-equal? (pascal-triangle 3 2) 2)
(check-equal? (pascal-triangle 4 2) 3)
(check-equal? (pascal-triangle 5 2) 4)
(check-equal? (pascal-triangle 5 3) 6)