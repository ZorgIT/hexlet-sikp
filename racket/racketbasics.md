hexlet https://ru.code-basics.com/languages/racket
Без указания #lang racket интерпритатор не сработает


===
#lang racket
(displayln "Hello, World!") 
===

Lisp = LISt Processor (Обработчик списков). Односвязный список - онсовная структура данных.
Любая программа - сама по себе список.

Гомоиконичность - Код на Lisp Одновременно является данными Lisp-языка. Позволяет писать макросы, работающие с исходным кодом как со списком.

Список как дерево.
Списки могут быть вложенными.
Пример. (+ 1 (- 3 2)) ; сложение или список из трёх элементов, в котором третий элемент — список из трёх элементов
Список - рекурсивная структура данных. Любой элемент может быть списком и содержать внутри себя элементы-списки.

L5 ===
`Порядок вычисления`
задача 5 + 7 + (8 - 3) - (8 * 5)
решение (- (+ 5 7 (- 8 3)) (* 5 8))

L6 ====
`Скобки`


L7 ====
`Объявление символов`
переменные создаются с помощью конструкции define и называются объявлениями.

(define id expr)
; id — идентификатор
; expr — выражение

Для изменения значения объявления используется функция set! (использование set! не рекомендовано
лучше заменять все на константы.)
(set! lang "scheme")
(displayln lang) ; => scheme

L8 === 
`Создание и вызов функций`
; определение функции, вычисляющей сумму двух чисел
(lambda (x y) (+ x y))

тело может состоять из нескольких форм (как минимум из одной):
(lambda ()
  (displayln "one")
  (displayln "two"))
  Возвращается ВСЕГДА последнее вычисленное выражение.

примеры
; печать на экран
(lambda () (displayln "hello!"))
; квадрат числа
(lambda (n) (* n n))

; среднее между двумя числами
(lambda (num1 num2) (/ (+ num1 num2) 2))

(define cube (lambda (x) (* x x x))) ; функция вычисляющая куб переданного числа.

L9 ====
`Вызов функции без define`
((lambda (n) (* n n)) 5)
в форме вызова сразу после функции перечисляются параметры.

Пример для двух параметров.
((lambda (x y) (+ x y))
 8 7) ; 15

пример объявления и вызова функции:
 (define result
  ((lambda (num1 num2) (/ (+ num1 num2) 2))
   2 4))

(displayln result)

L10 ====
`Сокращенный синтаксис создания функции`
Полная запись
(define square (lambda (n) (* n n)))

Сокращенная запись
(define (square n) (* n n))

ример объявления функции с двумя аргументами:

(define (sum x y) (+ x y))

Сумма квадратов двух чисел.
(define (sum-of-squares x y) (+ (* x x) (* y y)))

L10 ====
`Модули`
Обычно каждый файл содержит ровно один модуль.
По умолчанию все объявления, сделанные в модуле, остаются внутри модуля.
импорт объявлений из других модулей проихсодит с помощью формы requre

(require "math.rkt") // пример.

Нельзя исопльзовать объявления другого модуля если модуль не экспортирует их явно. Для экспорта объявлений используется форма provide

; math.rkt
#lang racket
(provide sum)
(define (sum a b) (+ a b))

В provide пеерчисляются именя объявлений, которые нужно экспортировать. Любой другой модуль автоматически получает доступ ко всем экспортируемым объявлениям при импорте.
экспортивровать все объявления модулям можно с применением формы (provide (all-defined-out))

require работает с путями (абсолютными и относительными)
require автоматически делает доступным все, что в импортируемом модуле указано в provide.
Существует альтернативный способ вызова require
(require (only-in "math.rkt" sum)) - only-in говорит что надо включить из модуля переменную sum и больше ничего.